### 선언
```go
package main
import "fmt"

func main() {
	a := [5]int{1, 2, 3, 4, 5} // []안에 갯수를 넣으면 배열
	fmt.Println(a)  // 참고로 fmt.Println() 말고 그냥 Println()하면 오류남
	b := []int{1, 2, 3, 4} // []안에 갯수를 안써넣으면 슬라이스
	fmt.Println(b)
}
```
### 뭔차인데
* 배열은 고정, 정적배열이고 슬라이스는 가변, 동적배열이다.
* 슬라이스에는 append, 슬라이싱 등이 가능하지만 배열은 진짜 C에 딱딱한 그 배열임.

### 슬라이싱, 부분 
```go
b := []int{1, 2, 3, 4, 5, 6, 7} // [이상 index num : 미만 index num]
fmt.Println(b[5:])              // 결과값 [6 7]
fmt.Println(b[:3])              // 결과값 [1 2 3]
fmt.Println(b[2:4])             // 결과값 [3 4]
```

### 슬라이스 관련요소
#### make
* 슬라이스를 만들기 위해선 여러가지 방법이 있는데 그 중 하나가 make 함수를 사용하는것이다.
```go
c := make([]int, 5) // [0 0 0 0 0]로 생성
d := make([]int, 5, 10) // 위와 같지만 용량이 더 큰 슬라이스 생성
```
#### append
* 슬라이스의 맨 뒤에 값을 추가함.
* append로는 첫 인자만 슬라이스를 넣고 그 뒤로는 갯수 상관없이 계속 넣는다.
* 슬라이스와 슬라이스를 붙이려면 두 번째 슬라이스 뒤로 ...을 붙여야한다.
```go
c := make([]int, 5) // [0 0 0 0 0]로 생성
c = append(c, 1)    // 이러면 c = [0 0 0 0 0 1]
c = append(c, 2, 3, 4) // 이러면 c = [0 0 0 0 0 1 2 3 4]
d := []int{10, 11}
c = append(c, d...) // ...을 붙여야한다. 이러면 c = [0 0 0 0 0 1 2 3 4 10 11]
```
#### 배열복사 (= 연산자의 경우)
```go
a := []int{1, 2, 3}
var b []int    // 슬라이스로 선언

b = a          // a를 b에 대입해도 요소가 모두 복사되지 않고 참조만 함
b[0] = 9       // 슬라이스는 참조이므로 a[0], b[0]의 값이 모두 바뀜

fmt.Println(a) // [9 2 3]
fmt.Println(b) // [9 2 3]
```

#### 배열복사 (내장함수 copy의 경우)
```go
a := []int{1, 2, 3}
b := make([]int, 3)

copy(b, a)     // 슬라이스를 복사하였으므로
b[0] = 9       // b[0]만 바뀌고, a[0]은 바뀌지 않음

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [9 2 3]
```

#### len, cap
* len은 슬라이스의 길이, cap은 용량이다.
* 어차피 len밖에 쓸일 없을듯, cap은 추가하면 늘어난다.
  * 시스템프로그래밍할때 쓰이지 않을까?? 잘 모르겠넹

```go
c := make([]int, 5) // [0 0 0 0 0]로 생성 
fmt.Println(len(c), cap(c)) //이러면 5 5가 나옴
```

#### range



#### Nil Slice
```go
var a []int

if len(a) == 0 && cap(a) == 0 {
  fmt.Println("이건 빈놈이다1")
}

if a == nil {
  fmt.Println("이건 빈놈이다2")
}
// 둘 다 빈놈임 
```

### 슬라이스의 구조
* 슬라이스는 시작포인터, 길이, 용량을 메타데이터로 가지고 있음.
* 다 바뀜
  * 당장 슬라이스만 하더라도, 시작주소, 길이, 용량 다 바뀜
